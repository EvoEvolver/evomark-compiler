
#slides{
    
    %t = $d{
        Characteristics of an Ideal Compiler    
    }

    %p = $def{
        - User Interface
        -- Precise and clear diagnostic messages
        -- Easy to use processing options
        - Correctly implements the entire language
        - Detects all statically detectable errors
        - Generates highly optimal code
        - Compiles quickly using modest system resources
        - Good software engineering practice
        -- Well modularized, well documented, thoroughly tested, etc.    
    }

    %s = $lm{
        Imagine you are a teacher giving a lecture and you are talking about %t with the following points:
        %p
        In the middle of the class, you are going over the points by explaining each of them and adding examples when it is needed. You should avoid using the same sentence as that in the points.
        Your script will be:    
    }{Now, let's discuss}

    $set{%s}('e7930dd5951462ff406fa574ce44e38f'){
        Now, let's discuss each of these characteristics of an ideal compiler in a bit more detail. 
        
        Starting with the User Interface, it's important that the compiler have a user-friendly layout. The user should be able to quickly find the options they need, enabling them to compile code quickly and accurately. The output of the compiler should be precise and the user should be given clear diagnostic messages when errors are encountered.
        
        Moving on, a good compiler should be able to correctly implement the entire language. All language-defined features should be supported and the compiler should detect all statically detectable errors. This ensures that the source code is being read, parsed and compiled accurately with no discrepancies.
        
        The compiler should also generate highly optimized code. This will help to improve the run-time performance of the application, allowing you to save on memory and processor cycles. Additionally, the compiler should compile quickly using modest system resources, so that code can be compiled quickly and efficiently.
        
        Finally, an ideal compiler should follow good software engineering practices. This includes being well modularized, documented, and thoroughly tested. These all help to ensure that the compiler is reliable and can produce accurate results with each compilation.    
    }

    #slide{
        #sec{%t}
        $put{
            #list{
            %p
            }        
        }
        #clk#voice{
            %s        
        }    
    }

    %t = $d{
        LLVM Compiler Infrastructure    
    }

    %p = $def{
        - Collection of industrial strength compiler technology
        -- A powerful intermediate representation LLVM IR
        -- Optimizer and code generator
        - Multiple backends for different architecture targets
        - Open source project with many contributors
        -- Industry, research groups, individuals
        -- De-facto standard of building modern compilers
        - Clang: C/C++ compiler built on top of LLVM    
    }

    %s = $lm{
        Imagine you are a teacher giving a lecture and you are talking about %t with the following points:
        %p
        In the middle of the class, you are going over the points by explaining each of them and adding examples when it is needed. You should avoid using the same sentence as that in the points.
        Your script will be:    
    }{Now, let's discuss}

    $set{%s}('29ef455352fc5921fb046034ecdb95d9'){
        Now, let's discuss LLVM Compiler Infrastructure. It is a collection of modern, industrial-grade compiler technology. It has its own intermediate representation language, LLVM IR, which is very powerful in nature. This IR provides an efficient way for compilers to read in and further optimize the code to generate a much better output. Moreover, it has a well-designed and optimized code generator which helps a lot in executing the generated code efficiently.
        
        
        Additionally, the project has multiple backends which can be leveraged to target different architectures. Furthermore, the project is open source and has contributions from various industry players, research groups, and individual developers which has helped to make it the de-facto standard of modern compilers today.
        
        
        Also, LLVM has another sub-project, Clang, which is a C/C++ compiler built on the top of its compiler infrastructure. This helps to make the process of creating optimized C/C++ applications more reliable and manageable.    
    }

    #slide{
        #sec{%t}
        $put{
            #list{
            %p
            }        
        }
        #clk#voice{
            %s        
        }    
    }
}

